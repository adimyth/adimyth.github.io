<!doctype html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
        integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <!-- Custom CSS-->
    <!-- <link rel="stylesheet" href="assets/css/styles.css"> -->
 
    <!-- Custom JS -->
    <script src="assets/js/highlight.pack.js"></script>

    <!-- Google Font-->
    <link href="//fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
    

    <title>Context Managers in Python</title>
</head>

<body class="container">
    <h1 id="contextmanagersinpython">Context Managers in Python</h1>

    <p><a href="https://jeffknupp.com/blog/2016/03/07/python-with-context-managers/">Link 1</a>
        <a href="http://arnavk.com/posts/python-context-managers/">Link 2</a></p>

    <ul>
        <li>The most common &amp; imp use of context managers is to manage resources, which are limited. Ex: opening a
            file consumes a resource => file descriptor.</li>
    </ul>

    <pre><code class="python">
        files = []
        for x in range(1100):
            files.append(open('foo.txt', 'w'))
    </code></pre>

    <ul>
        <li>Context managers gives us a simple way to make sure all resources being used are properly cleaned up,
            regardless of if the code returns an error or an exception is thrown i.e. it provides us convenient method
            for indicating a particular variable has some cleanup associated with it &amp; that cleanup happens, no
            matter what.</li>

        <li>Using <em>with</em>, we can call anything that returns a context manager (like the built-in open()
            function). </li>

        <li>Any object that needs to have close called on it after use is a context manager.</li>
    </ul>

    <h3 id="creatingacontextmanager">Creating a context manager</h3>

    <p><strong>Method 1</strong></p>

    <ul>
        <li>Create a class with two special methods <code>__enter__()</code> and <code>__exit__(*args)</code>. </li>

        <li><code>__enter__()</code> returns the resource to be managed.</li>

        <li><code>__exit__(*args)</code> does cleanup &amp; returns nothing.</li>
    </ul>

    <pre><code class="python">
        class FileHandler():
            def __init__(self):
                pass
        
            def __enter__(self):
                self.file_descriptor = open('somefile.txt', 'w')
                return self.file_descriptor
        
            def __exit__(self, *args): 
                self.file_descriptor.close()
    </code></pre>

    <ul>
        <li><code>__enter__()</code> should return an object that is assigned to the variable after as. </li>
    </ul>

    <p><strong>Method 2</strong></p>

    <ul>
        <li>Use the @contextmanager decorator in contextlib library to decorate a generator function.</li>

        <li>This generator must call <code>yield</code> once. Everything before the <code>yield</code> belongs to
            <code>__enter__()</code> and everything after it belongs to <code>__exit__()</code>.</li>
    </ul>

    <pre><code class="python">
        from contextlib import contextmanager
    
        @contextmanager
        def filehandler():
            file_descriptor = open('somfile.txt', 'w')
            yield file_descriptor
            file_descriptor.close()
    </code></pre>

    <h2>Examples</h2>
    <p>File manipulation</p>

    <pre><code class="python">
        with open('sample.txt', 'w') as file:
            file.write('Hello World!!!')
    </code></pre>

    <p>Multiprocessing</p>

    <pre><code class="python">
        from multiprocessing import Pool, cpu_count
        
        def f(x):
            return x*x
        
        num_processors = cpu_count()-1
        
        with Pool(num_processors) as pool:
            pool.map(f, range(10))
    </code></pre>

    <p>Reading &amp; Writing to a file at the same time</p>

    <pre><code class="python">
        from contextlib import contextmanager
        import io
        import os
        
        
        @contextmanager
        def inplace(filename, mode='r', buffering=-1, encoding=None, errors=None,
                    newline=None, backup_extension=None):
            """Allow for a file to be replaced with new content.
        
            yields a tuple of (readable, writable) file objects, where writable
            replaces readable.
        
            If an exception occurs, the old file is restored, removing the
            written data.
        
            mode should *not* use 'w', 'a' or '+'; only read-only-modes are supported.
        
            """
        
            # move existing file to backup, create new file with same permissions
            # borrowed extensively from the fileinput module
            if set(mode).intersection('wa+'):
                raise ValueError('Only read-only file modes can be used')
        
            backupfilename = filename + (backup_extension or os.extsep + 'bak')
            try:
                os.unlink(backupfilename)
            except os.error:
                pass
            os.rename(filename, backupfilename)
            readable = io.open(backupfilename, mode, buffering=buffering,
                            encoding=encoding, errors=errors, newline=newline)
            try:
                perm = os.fstat(readable.fileno()).st_mode
            except OSError:
                writable = open(filename, 'w' + mode.replace('r', ''),
                                buffering=buffering, encoding=encoding, errors=errors,
                                newline=newline)
            else:
                os_mode = os.O_CREAT | os.O_WRONLY | os.O_TRUNC
                if hasattr(os, 'O_BINARY'):
                    os_mode |= os.O_BINARY
                fd = os.open(filename, os_mode, perm)
                writable = io.open(fd, "w" + mode.replace('r', ''), buffering=buffering,
                                encoding=encoding, errors=errors, newline=newline)
                try:
                    if hasattr(os, 'chmod'):
                        os.chmod(filename, perm)
                except OSError:
                    pass
            try:
                yield readable, writable
            except Exception:
                # move backup back
                try:
                    os.unlink(filename)
                except os.error:
                    pass
                os.rename(backupfilename, filename)
                raise
            finally:
                readable.close()
                writable.close()
                try:
                    os.unlink(backupfilename)
                except os.error:
                    pass
        
        import csv
        
        with inplace(csvfilename, 'rb') as (infh, outfh):
            reader = csv.reader(infh)
            writer = csv.writer(outfh)
        
            for row in reader:
                row += ['new', 'columns']
                writer.writerow(row)
    </code></pre>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
        integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
        crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
        integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
        crossorigin="anonymous"></script>
</body>

</html>