<!doctype html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
        integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

    <!-- Custom JS -->
    <script src="assets/js/highlight.pack.js"></script>

    <!-- Google Font-->
    <link href="//fonts.googleapis.com/css?family=Roboto" rel="stylesheet">


    <title>MultiProcessing in Python</title>
</head>

<body class="container">
    <h1 id="multiprocessinginpython">MultiProcessing in Python</h1>

    <p>The multiprocessing library in python provides two ways to run processes parallely. It provides two ways to
        execute tasks</p>

    <ul>
        <li>Process </li>

        <li>Pool</li>
    </ul>

    <h3 id="pool">Pool</h3>

    <ul>
        <li>Distributes task to available processors using FIFO scheduling. Follows a map-reduce architecture.</li>

        <li>Maps input to different processors and collects output from all the processors. After completion, it returns
            the output as a list or an array. </li>

        <li>Only the process in execution are stored in memory and non-executing processes are stored out of memory.
        </li>

        <li>Pool distributes processes among the available cores in FIFO manner. On each core, the task is executed
            serially. In case of ops, that have long IO operation, it waits till the IO op is completed, increasing the
            execution time. So, in case of long IO operations, do not use Pool class.</li>

        <li>Beneficial to use if same operation is to be performed on large number of values.</li>
    </ul>

    <pre><code class="python ">
            from multiprocessing import Pool
            def square(x):
                return x**2
            
            a = [1, 2, 3, 4, 5]
            pool = Pool(processes=4)
            print(pool.map(square, a))
        </code></pre>

    <h3 id="process">Process</h3>

    <ul>
        <li>It puts all the processes in memory and follows the FIFO policy. </li>

        <li>For each input, it creates a separate process.</li>

        <li>Beneficial if there are only small number of tasks to execute in parallel and each task needs to be done
            only once.</li>

        <li>In case of long IO operations, the Process class suspends the process executing IO operations and schedules
            another process. So, in case of long IO operations, use Process class.</li>
    </ul>

    <pre><code class="python ">
            from multiprocessing import Process, current_process
            def square(x):
                print(f'Process Id: {current_process().pid}')
                return x**2
            
            a = [1, 2, 3, 4, 5]
            for i in a:
                p = Process(target=square, args=(i, ))
                p.start()
                p.join()
        </code></pre>

    <h5 id="communicationbetweenprocesses">Communication between processes</h5>

    <ul>
        <li>Communication between processes can be done using Queue.</li>
    </ul>

    <pre><code class="python ">
            import multiprocessing 
            result = [] 
            
            def square_list(mylist): 
                global result 
                for num in mylist: 
                    result.append(num * num) 
                print("Result(in process p1): {}".format(result)) 
            
            if __name__ == "__main__": 
                mylist = [1,2,3,4] 
            
                p1 = multiprocessing.Process(target=square_list, args=(mylist,)) 
                p1.start() 
                p1.join() 
            
                print("Result(in main program): {}".format(result)) 
            
            # Result(in process p1): [1, 4, 9, 16]
            # Result(in main program): []
        </code></pre>
    <hr>
    <pre><code class="python ">
            import multiprocessing 
            from multiprocessing import Queue
            def square_list(mylist, queue): 
                for num in mylist: 
                    queue.put(num * num) 
                print(f"Result(in process p1): {queue}") 
            
            if __name__ == "__main__": 
                mylist = [1,2,3,4] 
                queue = Queue()
                p1 = multiprocessing.Process(target=square_list, args=(mylist, queue)) 
                p1.start() 
                p1.join() 
                print(f"Result(in process p1): {queue}")
            
            Result(in process p1): &lt;multiprocessing.queues.Queue object at 0x7ffb1c1f65f8&gt;
            Result(in process p1): &lt;multiprocessing.queues.Queue object at 0x7ffb1c1f65f8&gt;
        </code></pre>

    <p>The memory is shared between the two processes.</p>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
        integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
        crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
        integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
        crossorigin="anonymous"></script>
</body>

</html>